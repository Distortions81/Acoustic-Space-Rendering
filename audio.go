package main

import (
	"encoding/binary"
	"io"
	"log"
	"math"

	"github.com/hajimehoshi/ebiten/v2/audio"
)

// ensurePressureSampleCapacity resizes the buffer that stores PCM samples.
func (g *Game) ensurePressureSampleCapacity(n int) {
	if g.audioDisabled {
		return
	}
	if n <= 0 {
		if g.latestPressureSamples != nil {
			g.latestPressureSamples = g.latestPressureSamples[:0]
		}
		return
	}
	if cap(g.latestPressureSamples) < n {
		g.latestPressureSamples = make([]int16, n)
	} else {
		g.latestPressureSamples = g.latestPressureSamples[:n]
	}
}

// setPressureSamples copies samples generated by the solver into the audio buffer.
func (g *Game) setPressureSamples(samples []int16) {
	if g.audioDisabled {
		return
	}
	g.ensurePressureSampleCapacity(len(samples))
	copy(g.latestPressureSamples, samples)
}

// initAudio prepares the Ebiten audio context and streaming pipe.
func (g *Game) initAudio() {
	if g.audioDisabled {
		return
	}
	g.audioSampleDur = 1.0 / float64(audioSampleRate)
	ctx := audio.CurrentContext()
	if ctx == nil {
		ctx = audio.NewContext(audioSampleRate)
	} else if ctx.SampleRate() != audioSampleRate {
		log.Printf("audio context sample rate %d does not match expected %d; disabling audio", ctx.SampleRate(), audioSampleRate)
		return
	}
	pr, pw := io.Pipe()
	player, err := ctx.NewPlayer(pr)
	if err != nil {
		log.Printf("creating audio player failed: %v", err)
		_ = pr.Close()
		_ = pw.Close()
		return
	}
	player.SetBufferSize(audioBufferDuration)
	g.audioCtx = ctx
	g.audioPlayer = player
	g.audioPipe = pw
	g.audioElapsed = 0
	g.audioNextTime = 0
	g.audioPCM = g.audioPCM[:0]
	player.Play()
}

// flushAudioBuffer writes pending PCM data into the streaming pipe.
func (g *Game) flushAudioBuffer() {
	if g.audioDisabled {
		g.audioPCM = g.audioPCM[:0]
		return
	}
	if len(g.audioPCM) == 0 {
		return
	}
	if g.audioPipe == nil {
		g.audioPCM = g.audioPCM[:0]
		return
	}
	byteLen := len(g.audioPCM) * 2
	if cap(g.audioWriteBuf) < byteLen {
		g.audioWriteBuf = make([]byte, byteLen)
	}
	buf := g.audioWriteBuf[:byteLen]
	for i, sample := range g.audioPCM {
		binary.LittleEndian.PutUint16(buf[i*2:], uint16(sample))
	}
	if _, err := g.audioPipe.Write(buf); err != nil {
		log.Printf("audio stream write failed: %v", err)
		_ = g.audioPipe.Close()
		g.audioPipe = nil
	} else if g.audioPlayer != nil && !g.audioPlayer.IsPlaying() {
		g.audioPlayer.Play()
	}
	g.audioPCM = g.audioPCM[:0]
}

// streamAudioSamples queues PCM data while maintaining temporal alignment with the simulation.
func (g *Game) streamAudioSamples(samples []int16, sourceRate float64) {
	if g.audioDisabled {
		return
	}
	if sourceRate <= 0 {
		sourceRate = float64(audioSampleRate)
	}
	chunkDuration := 0.0
	if len(samples) > 0 {
		chunkDuration = float64(len(samples)) / sourceRate
	}
	chunkStart := g.audioElapsed
	chunkEnd := chunkStart + chunkDuration
	if len(samples) == 0 {
		g.audioElapsed = chunkEnd
		if g.audioNextTime < g.audioElapsed {
			g.audioNextTime = g.audioElapsed
		}
		return
	}
	if g.audioNextTime < chunkStart {
		g.audioNextTime = chunkStart
	}
	g.audioPCM = g.audioPCM[:0]
	if math.Abs(sourceRate-float64(audioSampleRate)) < 1e-6 {
		startIndex := int(math.Round((g.audioNextTime - chunkStart) * sourceRate))
		if startIndex < 0 {
			startIndex = 0
		}
		if startIndex >= len(samples) {
			startIndex = len(samples) - 1
		}
		for idx := startIndex; idx < len(samples) && g.audioNextTime < chunkEnd; idx++ {
			sample := int(samples[idx])
			if sample > pcm16MaxValue {
				sample = pcm16MaxValue
			} else if sample < pcm16MinValue {
				sample = pcm16MinValue
			}
			g.audioPCM = append(g.audioPCM, int16(sample))
			g.audioNextTime += g.audioSampleDur
		}
	} else {
		step := sourceRate / float64(audioSampleRate)
		pos := (g.audioNextTime - chunkStart) * sourceRate
		for g.audioNextTime < chunkEnd {
			idx := int(math.Floor(pos))
			if idx < 0 {
				idx = 0
			}
			if idx >= len(samples) {
				idx = len(samples) - 1
			}
			g.audioPCM = append(g.audioPCM, samples[idx])
			g.audioNextTime += g.audioSampleDur
			pos += step
		}
	}
	g.audioElapsed = chunkEnd
	g.flushAudioBuffer()
}

// samplePressureAtIndex reads the pressure value used to generate audio output.
func (g *Game) samplePressureAtIndex() int16 {
	if g.field == nil || g.pressureSampleIndex < 0 || g.pressureSampleIndex >= len(g.field.curr) {
		return 0
	}
	return floatToPCM16(g.field.curr[g.pressureSampleIndex])
}
